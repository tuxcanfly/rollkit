<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rollkit Specifications</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="specs/template.html"><strong aria-hidden="true">1.</strong> Template</a></li><li class="chapter-item expanded "><a href="specs/rollkit-dependency-graph.html"><strong aria-hidden="true">2.</strong> Dependency Graph</a></li><li class="chapter-item expanded "><a href="specs/block-manager.html"><strong aria-hidden="true">3.</strong> Block Manager</a></li><li class="chapter-item expanded "><a href="specs/block-executor.html"><strong aria-hidden="true">4.</strong> Block Executor</a></li><li class="chapter-item expanded "><a href="specs/block-validity.html"><strong aria-hidden="true">5.</strong> Block Validity</a></li><li class="chapter-item expanded "><a href="specs/da.html"><strong aria-hidden="true">6.</strong> DA</a></li><li class="chapter-item expanded "><a href="specs/full_node.html"><strong aria-hidden="true">7.</strong> Full Node</a></li><li class="chapter-item expanded "><a href="specs/header-sync.html"><strong aria-hidden="true">8.</strong> Header Sync</a></li><li class="chapter-item expanded "><a href="specs/indexer-service.html"><strong aria-hidden="true">9.</strong> Indexer Service</a></li><li class="chapter-item expanded "><a href="specs/mempool.html"><strong aria-hidden="true">10.</strong> Mempool</a></li><li class="chapter-item expanded "><a href="specs/p2p.html"><strong aria-hidden="true">11.</strong> P2P</a></li><li class="chapter-item expanded "><a href="specs/rpc-equivalency-coverage.html"><strong aria-hidden="true">12.</strong> RPC Equivalency</a></li><li class="chapter-item expanded "><a href="specs/state.html"><strong aria-hidden="true">13.</strong> State</a></li><li class="chapter-item expanded "><a href="specs/store.html"><strong aria-hidden="true">14.</strong> Store</a></li><li class="chapter-item expanded "><a href="specs/validators.html"><strong aria-hidden="true">15.</strong> Validators</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rollkit Specifications</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rollkit/rollkit" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Welcome to the Rollkit Specifications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocolcomponent-name"><a class="header" href="#protocolcomponent-name">Protocol/Component Name</a></h1>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>Provide a concise description of the purpose of the component for which the
specification is written, along with its contribution to the rollkit or
other relevant parts of the system. Make sure to include proper references to
the relevant sections.</p>
<h2 id="protocolcomponent-description"><a class="header" href="#protocolcomponent-description">Protocol/Component Description</a></h2>
<p>Offer a comprehensive explanation of the protocol, covering aspects such as data
flow, communication mechanisms, and any other details necessary for
understanding the inner workings of this component.</p>
<h2 id="message-structurecommunication-format"><a class="header" href="#message-structurecommunication-format">Message Structure/Communication Format</a></h2>
<p>If this particular component is expected to communicate over the network,
outline the structure of the message protocol, including details such as field
interpretation, message format, and any other relevant information.</p>
<h2 id="assumptions-and-considerations"><a class="header" href="#assumptions-and-considerations">Assumptions and Considerations</a></h2>
<p>If there are any assumptions required for the component's correct operation,
performance, security, or other expected features, outline them here.
Additionally, provide any relevant considerations related to security or other
concerns.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>Include a link to the location where the implementation of this protocol can be
found. Note that specific implementation details should be documented in the
rollkit repository rather than in the specification document.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>List any references used or cited in the document.</p>
<h2 id="general-tips"><a class="header" href="#general-tips">General Tips</a></h2>
<h3 id="how-to-use-a-mermaid-diagram-that-you-can-display-in-a-markdown"><a class="header" href="#how-to-use-a-mermaid-diagram-that-you-can-display-in-a-markdown">How to use a mermaid diagram that you can display in a markdown</a></h3>
<pre><code class="language-mermaid">
sequenceDiagram
    title Example
    participant A
    participant B
    A-&gt;&gt;B: Example
    B-&gt;&gt;A: Example

</code></pre>
<pre><code class="language-mermaid">
graph LR
   A[Example] --&gt; B[Example]
   B --&gt; C[Example]
   C --&gt; A

</code></pre>
<pre><code class="language-mermaid">
gantt
   title Example
   dateFormat  YYYY-MM-DD
   section Example
   A :done,    des1, 2014-01-06,2014-01-08
   B :done,    des2, 2014-01-06,2014-01-08
   C :done,    des3, 2014-01-06,2014-01-08

</code></pre>
<h3 id="grammar-and-spelling-check"><a class="header" href="#grammar-and-spelling-check">Grammar and spelling check</a></h3>
<p>The recommendation is to use your favorite spellchecker extension in your IDE like <a href="https://www.grammarly.com/">grammarly</a>, to make sure that the document is free of spelling and grammar errors.</p>
<h3 id="use-of-links"><a class="header" href="#use-of-links">Use of links</a></h3>
<p>If you want to use links use proper syntax. This goes for both internal and external links like <a href="specs/../README.html">documentation</a> or <a href="https://github.com/celestiaorg/go-header">external links</a></p>
<p>At the bottom of the document in <a href="specs/template.html#references">Reference</a>, you can add the following footnotes that will be visible in the markdown document:</p>
<p>[1] <a href="https://www.grammarly.com/">Grammarly</a></p>
<p>[2] <a href="specs/../README.html">Documentation</a></p>
<p>[3] <a href="https://github.com/celestiaorg/go-header">external links</a></p>
<p>Then at the bottom add the actual links that will not be visible in the markdown document:</p>
<h3 id="use-of-tables"><a class="header" href="#use-of-tables">Use of tables</a></h3>
<p>If you are describing variables, components or other things in a structured list that can be described in a table use the following syntax:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td><code>type</code></td><td>Description</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rollkit-dependency-graph"><a class="header" href="#rollkit-dependency-graph">Rollkit Dependency Graph</a></h1>
<p><img src="specs/./dependency-graph.drawio.svg" alt="Dependency Graph" /></p>
<p>We use the following color coding in this Graph:</p>
<ul>
<li>No Colour: Work not yet started</li>
<li>Yellow Box: Work in progress</li>
<li>Green Box: Work completed or at least unblocking the next dependency</li>
<li>Red Border: Work needs to happen in cooperation with another team</li>
</ul>
<p>If the EPICs are not linked to the box yet, it means that this box has currently no priority or is still in the ideation phase or the dependency is unclear.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block-manager"><a class="header" href="#block-manager">Block Manager</a></h1>
<h2 id="abstract-1"><a class="header" href="#abstract-1">Abstract</a></h2>
<p>The block manager is a key component of full nodes and is responsible for block production or block syncing depending on the node type: sequencer or non-sequencer. Block syncing in this context includes retrieving the published blocks from the network (P2P network or DA network), validating them to raise fraud proofs upon validation failure, updating the state, and storing the validated blocks. A full node invokes multiple block manager functionalities in parallel, such as:</p>
<ul>
<li>Block Production (only for sequencer full nodes)</li>
<li>Block Publication to DA network</li>
<li>Block Retrieval from DA network</li>
<li>Block Sync Service</li>
<li>Block Publication to P2P network</li>
<li>Block Retrieval from P2P network</li>
<li>State Update after Block Retrieval</li>
</ul>
<pre><code class="language-mermaid">sequenceDiagram
    title Overview of Block Manager

    participant User
    participant Sequencer
    participant Full Node 1
    participant Full Node 2
    participant DA Layer

    User-&gt;&gt;Sequencer: Send Tx
    Sequencer-&gt;&gt;Sequencer: Generate Block
    Sequencer-&gt;&gt;DA Layer: Publish Block

    Sequencer-&gt;&gt;Full Node 1: Gossip Block
    Sequencer-&gt;&gt;Full Node 2: Gossip Block
    Full Node 1-&gt;&gt;Full Node 1: Verify Block
    Full Node 1-&gt;&gt;Full Node 2: Gossip Block
    Full Node 1-&gt;&gt;Full Node 1: Mark Block Soft Confirmed

    Full Node 2-&gt;&gt;Full Node 2: Verify Block
    Full Node 2-&gt;&gt;Full Node 2: Mark Block Soft Confirmed

    DA Layer-&gt;&gt;Full Node 1: Retrieve Block
    Full Node 1-&gt;&gt;Full Node 1: Mark Block DA Included

    DA Layer-&gt;&gt;Full Node 2: Retrieve Block
    Full Node 2-&gt;&gt;Full Node 2: Mark Block DA Included
</code></pre>
<h2 id="protocolcomponent-description-1"><a class="header" href="#protocolcomponent-description-1">Protocol/Component Description</a></h2>
<p>The block manager is initialized using several parameters as defined below:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Name</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>signing key</td><td>crypto.PrivKey</td><td>used for signing a block after it is created</td></tr>
<tr><td>config</td><td>config.BlockManagerConfig</td><td>block manager configurations (see config options below)</td></tr>
<tr><td>genesis</td><td>*cmtypes.GenesisDoc</td><td>initialize the block manager with genesis state (genesis configuration defined in <code>config/genesis.json</code> file under the app directory)</td></tr>
<tr><td>store</td><td>store.Store</td><td>local datastore for storing rollup blocks and states (default local store path is <code>$db_dir/rollkit</code> and <code>db_dir</code> specified in the <code>config.toml</code> file under the app directory)</td></tr>
<tr><td>mempool, proxyapp, eventbus</td><td>mempool.Mempool, proxy.AppConnConsensus, *cmtypes.EventBus</td><td>for initializing the executor (state transition function). mempool is also used in the manager to check for availability of transactions for lazy block production</td></tr>
<tr><td>dalc</td><td>da.DAClient</td><td>the data availability light client used to submit and retrieve blocks to DA network</td></tr>
<tr><td>blockstore</td><td>*goheaderstore.Store[*types.Block]</td><td>to retrieve blocks gossiped over the P2P network</td></tr>
</tbody></table>
</div>
<p>Block manager configuration options:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>BlockTime</td><td>time.Duration</td><td>time interval used for block production and block retrieval from block store (<a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L36"><code>defaultBlockTime</code></a>)</td></tr>
<tr><td>DABlockTime</td><td>time.Duration</td><td>time interval used for both block publication to DA network and block retrieval from DA network (<a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L33"><code>defaultDABlockTime</code></a>)</td></tr>
<tr><td>DAStartHeight</td><td>uint64</td><td>block retrieval from DA network starts from this height</td></tr>
<tr><td>LazyBlockTime</td><td>time.Duration</td><td>time interval used for block production in lazy aggregator mode even when there are no transactions (<a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L39"><code>defaultLazyBlockTime</code></a>)</td></tr>
</tbody></table>
</div>
<h3 id="block-production"><a class="header" href="#block-production">Block Production</a></h3>
<p>When the full node is operating as a sequencer (aka aggregator), the block manager runs the block production logic. There are two modes of block production, which can be specified in the block manager configurations: <code>normal</code> and <code>lazy</code>.</p>
<p>In <code>normal</code> mode, the block manager runs a timer, which is set to the <code>BlockTime</code> configuration parameter, and continuously produces blocks at <code>BlockTime</code> intervals.</p>
<p>In <code>lazy</code> mode, the block manager starts building a block when any transaction becomes available in the mempool. After the first notification of the transaction availability, the manager will wait for a 1 second timer to finish, in order to collect as many transactions from the mempool as possible. The 1 second delay is chosen in accordance with the default block time of 1s. The block manager also notifies the full node after every lazy block building.</p>
<h4 id="building-the-block"><a class="header" href="#building-the-block">Building the Block</a></h4>
<p>The block manager of the sequencer nodes performs the following steps to produce a block:</p>
<ul>
<li>Call <code>CreateBlock</code> using executor</li>
<li>Sign the block using <code>signing key</code> to generate commitment</li>
<li>Call <code>ApplyBlock</code> using executor to generate an updated state</li>
<li>Save the block, validators, and updated state to local store</li>
<li>Add the newly generated block to <code>pendingBlocks</code> queue</li>
<li>Publish the newly generated block to channels to notify other components of the sequencer node (such as block and header gossip)</li>
</ul>
<h3 id="block-publication-to-da-network"><a class="header" href="#block-publication-to-da-network">Block Publication to DA Network</a></h3>
<p>The block manager of the sequencer full nodes regularly publishes the produced blocks (that are pending in the <code>pendingBlocks</code> queue) to the DA network using the <code>DABlockTime</code> configuration parameter defined in the block manager config. In the event of failure to publish the block to the DA network, the manager will perform <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L50"><code>maxSubmitAttempts</code></a> attempts and an exponential backoff interval between the attempts. The exponential backoff interval starts off at <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L59"><code>initialBackoff</code></a> and it doubles in the next attempt and capped at <code>DABlockTime</code>. A successful publish event leads to the emptying of <code>pendingBlocks</code> queue and a failure event leads to proper error reporting without emptying of <code>pendingBlocks</code> queue.</p>
<h3 id="block-retrieval-from-da-network"><a class="header" href="#block-retrieval-from-da-network">Block Retrieval from DA Network</a></h3>
<p>The block manager of the full nodes regularly pulls blocks from the DA network at <code>DABlockTime</code> intervals and starts off with a DA height read from the last state stored in the local store or <code>DAStartHeight</code> configuration parameter, whichever is the latest. The block manager also actively maintains and increments the <code>daHeight</code> counter after every DA pull. The pull happens by making the <code>RetrieveBlocks(daHeight)</code> request using the Data Availability Light Client (DALC) retriever, which can return either <code>Success</code>, <code>NotFound</code>, or <code>Error</code>. In the event of an error, a retry logic kicks in after a delay of 100 milliseconds delay between every retry and after 10 retries, an error is logged and the <code>daHeight</code> counter is not incremented, which basically results in the intentional stalling of the block retrieval logic. In the block <code>NotFound</code> scenario, there is no error as it is acceptable to have no rollup block at every DA height. The retrieval successfully increments the <code>daHeight</code> counter in this case. Finally, for the <code>Success</code> scenario, first, blocks that are successfully retrieved are marked as DA included and are sent to be applied (or state update). A successful state update triggers fresh DA and block store pulls without respecting the <code>DABlockTime</code> and <code>BlockTime</code> intervals.</p>
<h4 id="out-of-order-rollup-blocks-on-da"><a class="header" href="#out-of-order-rollup-blocks-on-da">Out-of-Order Rollup Blocks on DA</a></h4>
<p>Rollkit should support blocks arriving out-of-order on DA, like so:
<img src="https://github.com/rollkit/rollkit/blob/32839c86634a64aa5646bfd1e88bf37b86b81fec/block/out-of-order-blocks.png?raw=true" alt="out-of-order blocks" /></p>
<h4 id="termination-condition"><a class="header" href="#termination-condition">Termination Condition</a></h4>
<p>If the sequencer double-signs two blocks at the same height, evidence of the fault should be posted to DA. Rollkit full nodes should process the longest valid chain up to the height of the fault evidence, and terminate. See diagram:
<img src="https://github.com/rollkit/rollkit/blob/32839c86634a64aa5646bfd1e88bf37b86b81fec/block/termination.png?raw=true" alt="termination conidition" /></p>
<h3 id="block-sync-service"><a class="header" href="#block-sync-service">Block Sync Service</a></h3>
<p>The block sync service is created during full node initialization. After that, during the block manager's initialization, a pointer to the block store inside the block sync service is passed to it. Blocks created in the block manager are then passed to the <code>BlockCh</code> channel and then sent to the <a href="https://github.com/celestiaorg/go-header">go-header</a> service to be gossiped blocks over the P2P network.</p>
<h3 id="block-publication-to-p2p-network"><a class="header" href="#block-publication-to-p2p-network">Block Publication to P2P network</a></h3>
<p>Blocks created by the sequencer that are ready to be published to the P2P network are sent to the <code>BlockCh</code> channel in Block Manager inside <code>publishLoop</code>.
The <code>blockPublishLoop</code> in the full node continuously listens for new blocks from the <code>BlockCh</code> channel and when a new block is received, it is written to the block store and broadcasted to the network using the block sync service.</p>
<p>Among non-sequencer full nodes, all the block gossiping is handled by the block sync service, and they do not need to publish blocks to the P2P network using any of the block manager components.</p>
<h3 id="block-retrieval-from-p2p-network"><a class="header" href="#block-retrieval-from-p2p-network">Block Retrieval from P2P network</a></h3>
<p>For non-sequencer full nodes, Blocks gossiped through the P2P network are retrieved from the <code>Block Store</code> in <code>BlockStoreRetrieveLoop</code> in Block Manager.
Starting off with a block store height of zero, for every <code>blockTime</code> unit of time, a signal is sent to the <code>blockStoreCh</code> channel in the block manager and when this signal is received, the <code>BlockStoreRetrieveLoop</code> retrieves blocks from the block store.
It keeps track of the last retrieved block's height and every time the current block store's height is greater than the last retrieved block's height, it retrieves all blocks from the block store that are between these two heights.
For each retrieved block, it sends a new block event to the <code>blockInCh</code> channel which is the same channel in which blocks retrieved from the DA layer are sent.
This block is marked as soft confirmed by the validating full node until the same block is seen on the DA layer and then marked DA-included.</p>
<p>Although a sequencer does not need to retrieve blocks from the P2P network, it still runs the <code>BlockStoreRetrieveLoop</code>.</p>
<h4 id="about-soft-confirmations-and-da-inclusions"><a class="header" href="#about-soft-confirmations-and-da-inclusions">About Soft Confirmations and DA Inclusions</a></h4>
<p>The block manager retrieves blocks from both the P2P network and the underlying DA network because the blocks are available in the P2P network faster and DA retrieval is slower (e.g., 1 second vs 15 seconds). The blocks retrieved from the P2P network are only marked as soft confirmed until the DA retrieval succeeds on those blocks and they are marked DA included. DA included blocks can be considered to have a higher level of finality.</p>
<h3 id="state-update-after-block-retrieval"><a class="header" href="#state-update-after-block-retrieval">State Update after Block Retrieval</a></h3>
<p>The block manager stores and applies the block to update its state every time a new block is retrieved either via the P2P or DA network. State update involves:</p>
<ul>
<li><code>ApplyBlock</code> using executor: validates the block, executes the block (applies the transactions), captures the validator updates, and creates an updated state.</li>
<li><code>Commit</code> using executor: commit the execution and changes, update mempool, and publish events</li>
<li>Store the block, the validators, and the updated state.</li>
</ul>
<h2 id="message-structurecommunication-format-1"><a class="header" href="#message-structurecommunication-format-1">Message Structure/Communication Format</a></h2>
<p>The communication between the block manager and executor:</p>
<ul>
<li><code>InitChain</code>: using the genesis, a set of parameters, and validator set to invoke <code>InitChainSync</code> on the proxyApp to obtain initial <code>appHash</code> and initialize the state.</li>
<li><code>Commit</code>: commit the execution and changes, update mempool, and publish events.</li>
<li><code>CreateBlock</code>: prepare a block by polling transactions from mempool.</li>
<li><code>ApplyBlock</code>: validate the block, execute the block (apply transactions), validator updates, create and return updated state</li>
</ul>
<p>The communication between the full node and block manager:</p>
<ul>
<li>Notify when the block is published</li>
<li>Notify when the block is done lazy building</li>
</ul>
<h2 id="assumptions-and-considerations-1"><a class="header" href="#assumptions-and-considerations-1">Assumptions and Considerations</a></h2>
<ul>
<li>The block manager loads the initial state from the local store and uses genesis if not found in the local store, when the node (re)starts.</li>
<li>The default mode for sequencer nodes is normal (not lazy).</li>
<li>The sequencer can produce empty blocks.</li>
<li>The block manager uses persistent storage (disk) when the <code>root_dir</code> and <code>db_path</code> configuration parameters are specified in <code>config.toml</code> file under the app directory. If these configuration parameters are not specified, the in-memory storage is used, which will not be persistent if the node stops.</li>
<li>The block manager does not re-apply the block again (in other words, create a new updated state and persist it) when a block was initially applied using P2P block sync, but later was DA included during DA retrieval. The block is only marked DA included in this case.</li>
<li>The block sync store is created by prefixing <code>blockSync</code> on the main data store.</li>
<li>The genesis <code>ChainID</code> is used to create the <code>PubSubTopID</code> in go-header with the string <code>-block</code> appended to it. This append is because the full node also has a P2P header sync running with a different P2P network. Refer to go-header specs for more details.</li>
<li>Block sync over the P2P network works only when a full node is connected to the P2P network by specifying the initial seeds to connect to via <code>P2PConfig.Seeds</code> configuration parameter when starting the full node.</li>
<li>Node's context is passed down to all the components of the P2P block sync to control shutting down the service either abruptly (in case of failure) or gracefully (during successful scenarios).</li>
</ul>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">block-manager</a></p>
<p>See <a href="https://rollkit.dev/guides/full-and-sequencer-node">tutorial</a> for running a multi-node network with both sequencer and non-sequencer full nodes.</p>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<p>[1] <a href="https://github.com/celestiaorg/go-header">Go Header</a></p>
<p>[2] <a href="https://github.com/rollkit/rollkit/blob/main/block/sync_service.go">Block Sync</a></p>
<p>[3] <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go">Full Node</a></p>
<p>[4] <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">Block Manager</a></p>
<p>[5] <a href="https://rollkit.dev/guides/full-and-sequencer-node">Tutorial</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block-executor"><a class="header" href="#block-executor">Block Executor</a></h1>
<h2 id="abstract-2"><a class="header" href="#abstract-2">Abstract</a></h2>
<p>The <code>BlockExecutor</code> is a component responsible for creating, applying, and maintaining blocks and state in the system. It interacts with the mempool and the application via the <a href="https://github.com/cometbft/cometbft/blob/main/spec/abci/abci%2B%2B_basic_concepts.md">ABCI interface</a>.</p>
<h2 id="detailed-description"><a class="header" href="#detailed-description">Detailed Description</a></h2>
<p>The <code>BlockExecutor</code> is initialized with a proposer address, <code>namespace ID</code>, <code>chain ID</code>, <code>mempool</code>, <code>proxyApp</code>, <code>eventBus</code>, and <code>logger</code>. It uses these to manage the creation and application of blocks. It also validates blocks and commits them, updating the state as necessary.</p>
<ul>
<li>
<p><code>NewBlockExecutor</code>: This method creates a new instance of <code>BlockExecutor</code>. It takes a proposer address, <code>namespace ID</code>, <code>chain ID</code>, <code>mempool</code>, <code>proxyApp</code>, <code>eventBus</code>, and <code>logger</code> as parameters. See <a href="https://github.com/rollkit/rollkit/blob/main/block/block-manager.md">block manager</a> for details.</p>
</li>
<li>
<p><code>InitChain</code>: This method initializes the chain by calling ABCI <code>InitChainSync</code> using the consensus connection to the app. It takes a <code>GenesisDoc</code> as a parameter. It sends a ABCI <code>RequestInitChain</code> message with the genesis parameters including:</p>
<ul>
<li>Genesis Time</li>
<li>Chain ID</li>
<li>Consensus Parameters including:
<ul>
<li>Block Max Bytes</li>
<li>Block Max Gas</li>
<li>Evidence Parameters</li>
<li>Validator Parameters</li>
<li>Version Parameters</li>
</ul>
</li>
<li>Initial Validator Set using genesis validators</li>
<li>Initial Height</li>
</ul>
</li>
<li>
<p><code>CreateBlock</code>: This method reaps transactions from the mempool and builds a block. It takes the state, the height of the block, last header hash, and the signature as parameters.</p>
</li>
<li>
<p><code>ApplyBlock</code>: This method applies the block to the state. Given the current state and block to be applied, it:</p>
<ul>
<li>
<p>Validates the block, as described in <code>Validate</code>.</p>
</li>
<li>
<p>Executes the block using app, as described in <code>execute</code>.</p>
</li>
<li>
<p>Captures the validator updates done in the execute block.</p>
</li>
<li>
<p>Updates the state using the block, block execution responses, and validator updates as described in <code>updateState</code>.</p>
</li>
<li>
<p>Returns the updated state, validator updates and errors, if any, after applying the block.</p>
</li>
<li>
<p>It can return the following named errors:</p>
<ul>
<li><code>ErrEmptyValSetGenerate</code>: returned when applying the validator changes would result in empty set.</li>
<li><code>ErrAddingValidatorToBased</code>: returned when adding validators to empty validator set.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Validate</code>: This method validates the block. It takes the state and the block as parameters. In addition to the basic <a href="https://github.com/rollkit/rollkit/blob/main/types/block_spec.md">block validation</a> rules, it applies the following validations:</p>
<ul>
<li>New block version must match block version of the state.</li>
<li>If state is at genesis, new block height must match initial height of the state.</li>
<li>New block height must be last block height + 1 of the state.</li>
<li>New block header <code>AppHash</code> must match state <code>AppHash</code>.</li>
<li>New block header <code>LastResultsHash</code> must match state <code>LastResultsHash</code>.</li>
<li>New block header <code>AggregatorsHash</code> must match state <code>Validators.Hash()</code>.</li>
</ul>
</li>
<li>
<p><code>Commit</code>: This method commits the block and updates the mempool. Given the updated state, the block, and the ABCI <code>ResponseFinalizeBlock</code> as parameters, it:</p>
<ul>
<li>Invokes app commit, basically finalizing the last execution, by  calling ABCI <code>Commit</code>.</li>
<li>Updates the mempool to inform that the transactions included in the block can be safely discarded.</li>
<li>Publishes the events produced during the block execution for indexing.</li>
</ul>
</li>
<li>
<p><code>updateState</code>: This method updates the state. Given the current state, the block, the ABCI <code>ResponseFinalizeBlock</code> and the validator updates, it validates the updated validator set, updates the state by applying the block and returns the updated state and errors, if any. The state consists of:</p>
<ul>
<li>Version</li>
<li>Chain ID</li>
<li>Initial Height</li>
<li>Last Block including:
<ul>
<li>Block Height</li>
<li>Block Time</li>
<li>Block ID</li>
</ul>
</li>
<li>Next Validator Set</li>
<li>Current Validator Set</li>
<li>Last Validators</li>
<li>Whether Last Height Validators changed</li>
<li>Consensus Parameters</li>
<li>Whether Last Height Consensus Parameters changed</li>
<li>App Hash</li>
</ul>
</li>
<li>
<p><code>execute</code>: This method executes the block. It takes the context, the state, and the block as parameters. It calls the ABCI method <code>FinalizeBlock</code> with the ABCI <code>RequestFinalizeBlock</code> containing the block hash, ABCI header, commit, transactions and returns the ABCI <code>ResponseFinalizeBlock</code> and errors, if any.</p>
</li>
<li>
<p><code>publishEvents</code>: This method publishes events related to the block. It takes the ABCI <code>ResponseFinalizeBlock</code>, the block, and the state as parameters.</p>
</li>
</ul>
<h2 id="message-structurecommunication-format-2"><a class="header" href="#message-structurecommunication-format-2">Message Structure/Communication Format</a></h2>
<p>The <code>BlockExecutor</code> communicates with the application via the <a href="https://github.com/cometbft/cometbft/blob/main/spec/abci/abci%2B%2B_basic_concepts.md">ABCI interface</a>. It calls the ABCI methods <code>InitChainSync</code>, <code>FinalizeBlock</code>, <code>Commit</code> for initializing a new chain and creating blocks, respectively.</p>
<h2 id="assumptions-and-considerations-2"><a class="header" href="#assumptions-and-considerations-2">Assumptions and Considerations</a></h2>
<p>The <code>BlockExecutor</code> assumes that there is consensus connection available to the app, which can be used to send and receive ABCI messages. In addition there are some important pre-condition and post-condition invariants, as follows:</p>
<ul>
<li>
<p><code>InitChain</code>:</p>
<ul>
<li>pre-condition:
<ul>
<li>state is at genesis.</li>
</ul>
</li>
<li>post-condition:
<ul>
<li>new chain is initialized.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>CreateBlock</code>:</p>
<ul>
<li>pre-condition:
<ul>
<li>chain is initialized</li>
</ul>
</li>
<li>post-condition:
<ul>
<li>new block is created</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>ApplyBlock</code>:</p>
<ul>
<li>pre-condition:
<ul>
<li>block is valid, using basic <a href="https://github.com/rollkit/rollkit/blob/main/types/block_spec.md">block validation</a> rules as well as validations performed in <code>Validate</code>, as described above.</li>
</ul>
</li>
<li>post-condition:
<ul>
<li>block is added to the chain, state is updated and block execution responses are captured.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Commit</code>:</p>
<ul>
<li>pre-condition:
<ul>
<li>block has been applied</li>
</ul>
</li>
<li>post-condition:
<ul>
<li>block is committed</li>
<li>mempool is cleared of block transactions</li>
<li>block events are published</li>
<li>state App Hash is updated with the result from <code>ResponseCommit</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h2>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/state/executor.go">block executor</a></p>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/state/executor.go">Block Executor</a></p>
<p>[2] <a href="https://github.com/rollkit/rollkit/blob/main/block/block-manager.md">Block Manager</a></p>
<p>[3] <a href="https://github.com/rollkit/rollkit/blob/main/types/block_spec.md">Block Validation</a></p>
<p>[4] <a href="https://github.com/cometbft/cometbft/blob/main/spec/abci/abci%2B%2B_basic_concepts.md">ABCI documentation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block-and-header-validity"><a class="header" href="#block-and-header-validity">Block and Header Validity</a></h1>
<h2 id="abstract-3"><a class="header" href="#abstract-3">Abstract</a></h2>
<p>Like all blockchains, rollups are defined as the chain of <strong>valid</strong> blocks from the genesis, to the head. Thus, the block and header validity rules define the chain.</p>
<p>Verifying a block/header is done in 3 parts:</p>
<ol>
<li>
<p>Verify correct serialization according to the protobuf spec</p>
</li>
<li>
<p>Perform basic validation of the types</p>
</li>
<li>
<p>Perform verification of the new block against the previously accepted block</p>
</li>
</ol>
<h2 id="basic-validation"><a class="header" href="#basic-validation">Basic Validation</a></h2>
<p>Each type contains a <code>.ValidateBasic()</code> method, which verifies that certain basic invariants hold. The <code>ValidateBasic()</code> calls are nested, starting from the <code>Block</code> struct, all the way down to each subfield.</p>
<p>The nested basic validation, and validation checks, are called as follows:</p>
<pre><code class="language-go">Block.ValidateBasic()
  // Make sure the block's SignedHeader passes basic validation
  SignedHeader.ValidateBasic()
    // Make sure the SignedHeader's Header passes basic validation
    Header.ValidateBasic()
	  verify ProposerAddress not nil
	// Make sure the SignedHeader's signature passes basic validation
	Signature.ValidateBasic()
	  // Ensure that someone signed the block
	  verify len(c.Signatures) not 0
	If sh.Validators is nil, or len(sh.Validators.Validators) is 0, assume based rollup, pass validation, and skip all remaining checks.
	Validators.ValidateBasic()
	  // github.com/rollkit/cometbft/blob/main/types/validator.go#L37
	  verify sh.Validators is not nil, and len(sh.Validators.Validators) != 0
	  // apply basic validation to all Validators
	  for each validator:
	    validator.ValidateBasic()
		  validate not nil
		  validator.PubKey not nil
		  validator.VotingPower &gt;= 0
		  validator.Address == correct size
	  // apply ValidateBasic to the proposer field:
	  sh.Validators.Proposer.ValidateBasic()
		validate not nil
		validator.PubKey not nil
		validator.VotingPower &gt;= 0
		validator.Address == correct size
    Assert that SignedHeader.Validators.Hash() == SignedHeader.AggregatorsHash
	Verify SignedHeader.Signature
  Data.ValidateBasic() // always passes
  // make sure the SignedHeader's DataHash is equal to the hash of the actual data in the block.
  Data.Hash() == SignedHeader.DataHash
</code></pre>
<h2 id="verification-against-previous-block"><a class="header" href="#verification-against-previous-block">Verification Against Previous Block</a></h2>
<pre><code class="language-go">// code does not match spec: see https://github.com/rollkit/rollkit/issues/1277
Block.Verify()
  SignedHeader.Verify(untrustH *SignedHeader)
    // basic validation removed in #1231, because go-header already validates it
    //untrustH.ValidateBasic()
	Header.Verify(untrustH *SignedHeader)
	  if untrustH.Height == h.Height + 1, then apply the following check:
	    untrstH.AggregatorsHash[:], h.NextAggregatorsHash[:]
	if untrustH.Height &gt; h.Height + 1:
	  soft verification failure	
	// We should know they're adjacent now,
	// verify the link to previous.
	untrustH.LastHeaderHash == h.Header.Hash()
	// Verify LastCommit hash
	untrustH.LastCommitHash == sh.Signature.GetCommitHash(...)
	
</code></pre>
<h2 id="block"><a class="header" href="#block"><a href="https://github.com/rollkit/rollkit/blob/main/types/block.go#L26">Block</a></a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Field Name</strong></th><th><strong>Valid State</strong></th><th><strong>Validation</strong></th></tr></thead><tbody>
<tr><td>SignedHeader</td><td>Header of the block, signed by proposer</td><td>(See SignedHeader)</td></tr>
<tr><td>Data</td><td>Transaction data of the block</td><td>Data.Hash == SignedHeader.DataHash</td></tr>
</tbody></table>
</div>
<h2 id="signedheader"><a class="header" href="#signedheader"><a href="https://github.com/rollkit/rollkit/blob/main/types/signed_header.go#L16">SignedHeader</a></a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Field Name</strong></th><th><strong>Valid State</strong></th><th><strong>Validation</strong></th></tr></thead><tbody>
<tr><td>Header</td><td>Valid header for the block</td><td><code>Header</code> passes <code>ValidateBasic()</code> and <code>Verify()</code></td></tr>
<tr><td>Signature</td><td>1 valid signature from the centralized sequencer</td><td><code>Signature</code> passes <code>ValidateBasic()</code>, with additional checks in <code>SignedHeader.ValidateBasic()</code></td></tr>
<tr><td>Validators</td><td>Array of Aggregators, must have length exactly 1.</td><td><code>Validators</code> passes <code>ValidateBasic()</code></td></tr>
</tbody></table>
</div>
<h2 id="header"><a class="header" href="#header"><a href="https://github.com/rollkit/rollkit/blob/main/types/header.go#L39">Header</a></a></h2>
<p><em><strong>Note</strong></em>: The <code>AggregatorsHash</code> and <code>NextAggregatorsHash</code> fields have been removed. Rollkit vA should ignore all Valset updates from the ABCI app, and always enforce that the proposer is the centralized sequencer set as the 1 validator in the genesis block.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Field Name</strong></th><th><strong>Valid State</strong></th><th><strong>Validation</strong></th></tr></thead><tbody>
<tr><td><strong>BaseHeader</strong> .</td><td></td><td></td></tr>
<tr><td>Height</td><td>Height of the previous accepted header, plus 1.</td><td>checked in the `Verify()`` step</td></tr>
<tr><td>Time</td><td>Timestamp of the block</td><td>Not validated in Rollkit</td></tr>
<tr><td>ChainID</td><td>The hard-coded ChainID of the chain</td><td>Should be checked as soon as the header is received</td></tr>
<tr><td><strong>Header</strong> .</td><td></td><td></td></tr>
<tr><td>Version</td><td>unused</td><td></td></tr>
<tr><td>LastHeaderHash</td><td>The hash of the previous accepted block</td><td>checked in the `Verify()`` step</td></tr>
<tr><td>LastCommitHash</td><td>The hash of the previous accepted block's commit</td><td>checked in the `Verify()`` step</td></tr>
<tr><td>DataHash</td><td>Correct hash of the block's Data field</td><td>checked in the `ValidateBasic()`` step</td></tr>
<tr><td>ConsensusHash</td><td>unused</td><td></td></tr>
<tr><td>AppHash</td><td>The correct state root after executing the block's transactions against the accepted state</td><td>checked during block execution</td></tr>
<tr><td>LastResultsHash</td><td>Correct results from executing transactions</td><td>checked during block execution</td></tr>
<tr><td>ProposerAddress</td><td>Address of the expected proposer</td><td>checked in the <code>Verify()</code> step</td></tr>
<tr><td>Signature</td><td>Signature of the expected proposer</td><td>signature verification occurs in the <code>ValidateBasic()</code> step</td></tr>
</tbody></table>
</div>
<h2 id="validatorset"><a class="header" href="#validatorset"><a href="https://github.com/cometbft/cometbft/blob/main/types/validator_set.go#L51">ValidatorSet</a></a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Field Name</strong></th><th><strong>Valid State</strong></th><th><strong>Validation</strong></th></tr></thead><tbody>
<tr><td>Validators</td><td>Array of validators, each must pass <code>Validator.ValidateBasic()</code></td><td><code>Validator.ValidateBasic()</code></td></tr>
<tr><td>Proposer</td><td>Must pass <code>Validator.ValidateBasic()</code></td><td><code>Validator.ValidateBasic()</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="da"><a class="header" href="#da">DA</a></h1>
<p>Rollkit provides a wrapper for <a href="https://github.com/rollkit/go-da">go-da</a>, a generic data availability interface for modular blockchains, called <code>DAClient</code> with wrapper functionalities like <code>SubmitBlocks</code> and <code>RetrieveBlocks</code> to help block manager interact with DA more easily.</p>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<p><code>DAClient</code> can connect via either gRPC or JSON-RPC transports using the <a href="https://github.com/rollkit/go-da">go-da</a> <a href="https://github.com/rollkit/go-da/tree/main/proxy/grpc">proxy/grpc</a> or <a href="https://github.com/rollkit/go-da/tree/main/proxy/jsonrpc">proxy/jsonrpc</a> implementations. The connection can be configured using the following cli flags:</p>
<ul>
<li><code>--rollkit.da_address</code>: url address of the DA service (default: &quot;grpc://localhost:26650&quot;)</li>
<li><code>--rollkit.da_auth_token</code>: authentication token of the DA service</li>
<li><code>--rollkit.da_namespace</code>: namespace to use when submitting blobs to the DA service</li>
</ul>
<p>Given a set of blocks to be submitted to DA by the block manager, the <code>SubmitBlocks</code> first encodes the blocks using protobuf (the encoded data are called blobs) and invokes the <code>Submit</code> method on the underlying DA implementation. On successful submission (<code>StatusSuccess</code>), the DA block height which included in the rollup blocks is returned.</p>
<p>To make sure that the serialised blocks don't exceed the underlying DA's blob limits, it fetches the blob size limit by calling <code>Config</code> which returns the limit as <code>uint64</code> bytes, then includes serialised blocks until the limit is reached. If the limit is reached, it submits the partial set and returns the count of successfully submitted blocks as <code>SubmittedCount</code>. The caller should retry with the remaining blocks until all the blocks are submitted. If the first block itself is over the limit, it throws an error.</p>
<p>The <code>Submit</code> call may result in an error (<code>StatusError</code>) based on the underlying DA implementations on following scenarios:</p>
<ul>
<li>the total blobs size exceeds the underlying DA's limits (includes empty blobs)</li>
<li>the implementation specific failures, e.g., for <a href="https://github.com/rollkit/celestia-da">celestia-da</a>, invalid namespace, unable to create the commitment or proof, setting low gas price, etc, could return error.</li>
</ul>
<p>The <code>RetrieveBlocks</code> retrieves the rollup blocks for a given DA height using <a href="https://github.com/rollkit/go-da">go-da</a> <code>GetIDs</code> and <code>Get</code> methods. If there are no blocks available for a given DA height, <code>StatusNotFound</code> is returned (which is not an error case). The retrieved blobs are converted back to rollup blocks and returned on successful retrieval.</p>
<p>Both <code>SubmitBlocks</code> and <code>RetrieveBlocks</code> may be unsuccessful if the DA node and the DA blockchain that the DA implementation is using have failures. For example, failures such as, DA mempool is full, DA submit transaction is nonce clashing with other transaction from the DA submitter account, DA node is not synced, etc.</p>
<h2 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h2>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/da/da.go">da implementation</a></p>
<h2 id="references-3"><a class="header" href="#references-3">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/go-da">go-da</a></p>
<p>[2] <a href="https://github.com/rollkit/celestia-da">celestia-da</a></p>
<p>[3] <a href="https://github.com/rollkit/go-da/tree/main/proxy/grpc">proxy/grpc</a></p>
<p>[4] <a href="https://github.com/rollkit/go-da/tree/main/proxy/jsonrpc">proxy/jsonrpc</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="full-node"><a class="header" href="#full-node">Full Node</a></h1>
<h2 id="abstract-4"><a class="header" href="#abstract-4">Abstract</a></h2>
<p>A Full Node is a top-level service that encapsulates different components of Rollkit and initializes/manages them.</p>
<h2 id="details-1"><a class="header" href="#details-1">Details</a></h2>
<h3 id="full-node-details"><a class="header" href="#full-node-details">Full Node Details</a></h3>
<p>A Full Node is initialized inside the Cosmos SDK start script along with the node configuration, a private key to use in the P2P client, a private key for signing blocks as a block proposer, a client creator, a genesis document, and a logger. It uses them to initialize the components described above. The components TxIndexer, BlockIndexer, and IndexerService exist to ensure cometBFT compatibility since they are needed for most of the RPC calls from the <code>SignClient</code> interface from cometBFT.</p>
<p>Note that unlike a light node which only syncs and stores block headers seen on the P2P layer, the full node also syncs and stores full blocks seen on both the P2P network and the DA layer. Full blocks contain all the transactions published as part of the block.</p>
<p>The Full Node mainly encapsulates and initializes/manages the following components:</p>
<h3 id="proxyapp"><a class="header" href="#proxyapp">proxyApp</a></h3>
<p>The Cosmos SDK start script passes a client creator constructed using the relevant Cosmos SDK application to the Full Node's constructor which is then used to create the proxy app interface. When the proxy app is started, it establishes different <a href="https://github.com/cometbft/cometbft/blob/main/spec/abci/abci%2B%2B_basic_concepts.md">ABCI app connections</a> including Mempool, Consensus, Query, and Snapshot. The full node uses this interface to interact with the application.</p>
<h3 id="genesisdoc"><a class="header" href="#genesisdoc">genesisDoc</a></h3>
<p>The <a href="https://github.com/cometbft/cometbft/blob/main/spec/core/genesis.md">genesis</a> document contains information about the initial state of the rollup chain, in particular its validator set.</p>
<h3 id="conf"><a class="header" href="#conf">conf</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/config/config.go">node configuration</a> contains all the necessary settings for the node to be initialized and function properly.</p>
<h3 id="p2p"><a class="header" href="#p2p">P2P</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/p2p/client.go">peer-to-peer client</a> is used to gossip transactions between full nodes in the network.</p>
<h3 id="mempool"><a class="header" href="#mempool">Mempool</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/mempool/mempool.go">Mempool</a> is the transaction pool where all the transactions are stored before they are added to a block.</p>
<h3 id="store"><a class="header" href="#store">Store</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/store/store.go">Store</a> is initialized with <code>DefaultStore</code>, an implementation of the <a href="https://github.com/rollkit/rollkit/blob/main/store/types.go">store interface</a> which is used for storing and retrieving blocks, commits, and state. |</p>
<h3 id="blockmanager"><a class="header" href="#blockmanager">blockManager</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">Block Manager</a> is responsible for managing the operations related to blocks such as creating and validating blocks.</p>
<h3 id="dalc"><a class="header" href="#dalc">dalc</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/da/da.go">Data Availability Layer Client</a> is used to interact with the data availability layer. It is initialized with the DA Layer and DA Config specified in the node configuration.</p>
<h3 id="hexservice"><a class="header" href="#hexservice">hExService</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/block/sync_service.go">Header Sync Service</a> is used for syncing block headers between nodes over P2P.</p>
<h3 id="bsyncservice"><a class="header" href="#bsyncservice">bSyncService</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/block/sync_service.go">Block Sync Service</a> is used for syncing blocks between nodes over P2P.</p>
<h2 id="message-structurecommunication-format-3"><a class="header" href="#message-structurecommunication-format-3">Message Structure/Communication Format</a></h2>
<p>The Full Node communicates with other nodes in the network using the P2P client. It also communicates with the application using the ABCI proxy connections. The communication format is based on the P2P and ABCI protocols.</p>
<h2 id="assumptions-and-considerations-3"><a class="header" href="#assumptions-and-considerations-3">Assumptions and Considerations</a></h2>
<p>The Full Node assumes that the configuration, private keys, client creator, genesis document, and logger are correctly passed in by the Cosmos SDK. It also assumes that the P2P client, data availability layer client, mempool, block manager, and other services can be started and stopped without errors.</p>
<h2 id="implementation-4"><a class="header" href="#implementation-4">Implementation</a></h2>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go">full node</a></p>
<h2 id="references-4"><a class="header" href="#references-4">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go">Full Node</a></p>
<p>[2] <a href="https://github.com/cometbft/cometbft/blob/main/spec/abci/abci%2B%2B_basic_concepts.md">ABCI Methods</a></p>
<p>[3] <a href="https://github.com/cometbft/cometbft/blob/main/spec/core/genesis.md">Genesis Document</a></p>
<p>[4] <a href="https://github.com/rollkit/rollkit/blob/main/config/config.go">Node Configuration</a></p>
<p>[5] <a href="https://github.com/rollkit/rollkit/blob/main/p2p/client.go">Peer to Peer Client</a></p>
<p>[6] <a href="https://github.com/rollkit/rollkit/blob/main/mempool/mempool.go">Mempool</a></p>
<p>[7] <a href="https://github.com/rollkit/rollkit/blob/main/store/store.go">Store</a></p>
<p>[8] <a href="https://github.com/rollkit/rollkit/blob/main/store/types.go">Store Interface</a></p>
<p>[9] <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">Block Manager</a></p>
<p>[10] <a href="https://github.com/rollkit/rollkit/blob/main/da/da.go">Data Availability Layer Client</a></p>
<p>[11] <a href="https://github.com/rollkit/rollkit/blob/main/block/sync_service.go">Header Sync Service</a></p>
<p>[12] <a href="https://github.com/rollkit/rollkit/blob/main/block/sync_service.go">Block Sync Service</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="header-sync"><a class="header" href="#header-sync">Header Sync</a></h1>
<h2 id="abstract-5"><a class="header" href="#abstract-5">Abstract</a></h2>
<p>The nodes in the P2P network sync headers using the header sync service that implements the <a href="https://github.com/celestiaorg/go-header">go-header</a> interface. The header sync service consists of several components as listed below.</p>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td>store</td><td>a <code>headerEx</code> prefixed <a href="https://github.com/ipfs/go-datastore">datastore</a> where synced headers are stored</td></tr>
<tr><td>subscriber</td><td>a <a href="https://github.com/libp2p/go-libp2p">libp2p</a> node pubsub subscriber</td></tr>
<tr><td>P2P server</td><td>a server for handling header requests between peers in the P2P network</td></tr>
<tr><td>exchange</td><td>a client that enables sending in/out-bound header requests from/to the P2P network</td></tr>
<tr><td>syncer</td><td>a service for efficient synchronization for headers. When a P2P node falls behind and wants to catch up to the latest network head via P2P network, it can use the syncer.</td></tr>
</tbody></table>
</div>
<h2 id="details-2"><a class="header" href="#details-2">Details</a></h2>
<p>All three types of nodes (sequencer, full, and light) run the header sync service to maintain the canonical view of the rollup chain (with respect to the P2P network).</p>
<p>The header sync service inherits the <code>ConnectionGater</code> from the node's P2P client which enables blocking and allowing peers as needed by specifying the <code>P2PConfig.BlockedPeers</code> and <code>P2PConfig.AllowedPeers</code>.</p>
<p><code>NodeConfig.BlockTime</code> is used to configure the syncer such that it can effectively decide the outdated headers while it receives headers from the P2P network.</p>
<p>Both header and block sync utilizes <a href="https://github.com/celestiaorg/go-header">go-header</a> library and runs two separate sync services, for the headers and blocks. This distinction is mainly to serve light nodes which do not store blocks, but only headers synced from the P2P network.</p>
<h3 id="consumption-of-header-sync"><a class="header" href="#consumption-of-header-sync">Consumption of Header Sync</a></h3>
<p>The sequencer node, upon successfully creating the block, publishes the signed block header to the P2P network using the header sync service. The full/light nodes run the header sync service in the background to receive and store the signed headers from the P2P network. Currently the full/light nodes do not consume the P2P synced headers, however they have future utilities in performing certain checks.</p>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<ul>
<li>The header sync store is created by prefixing <code>headerSync</code> the main datastore.</li>
<li>The genesis <code>ChainID</code> is used to create the <code>PubsubTopicID</code> in <a href="https://github.com/celestiaorg/go-header">go-header</a>. For example, for ChainID <code>gm</code>, the pubsub topic id is <code>/gm/header-sub/v0.0.1</code>. Refer to go-header specs for further details.</li>
<li>The header store must be initialized with genesis header before starting the syncer service. The genesis header can be loaded by passing the genesis header hash via <code>NodeConfig.TrustedHash</code> configuration parameter or by querying the P2P network. This imposes a time constraint that full/light nodes have to wait for the sequencer to publish the genesis header to the P2P network before starting the header sync service.</li>
<li>The Header Sync works only when the node is connected to the P2P network by specifying the initial seeds to connect to via the <code>P2PConfig.Seeds</code> configuration parameter.</li>
<li>The node's context is passed down to all the components of the P2P header sync to control shutting down the service either abruptly (in case of failure) or gracefully (during successful scenarios).</li>
</ul>
<h2 id="implementation-5"><a class="header" href="#implementation-5">Implementation</a></h2>
<p>The header sync implementation can be found in <a href="https://github.com/rollkit/rollkit/blob/main/block/sync_service.go">block/sync_service.go</a>. The full and light nodes create and start the header sync service under <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go">full</a> and <a href="https://github.com/rollkit/rollkit/blob/main/node/light.go">light</a>.</p>
<h2 id="references-5"><a class="header" href="#references-5">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/block/sync_service.go">Header Sync</a></p>
<p>[2] <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go">Full Node</a></p>
<p>[3] <a href="https://github.com/rollkit/rollkit/blob/main/node/light.go">Light Node</a></p>
<p>[4] <a href="https://github.com/celestiaorg/go-header">go-header</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexer-service"><a class="header" href="#indexer-service">Indexer Service</a></h1>
<h2 id="abstract-6"><a class="header" href="#abstract-6">Abstract</a></h2>
<p>The Indexer service indexes transactions and blocks using events emitted by the block executor that can later be used to build services like block explorers that ingest this data.</p>
<h2 id="protocolcomponent-description-2"><a class="header" href="#protocolcomponent-description-2">Protocol/Component Description</a></h2>
<p>The Indexer service is started and stopped along with a Full Node. It consists of three main components: an event bus, a transaction indexer and a block indexer.</p>
<h3 id="event-bus"><a class="header" href="#event-bus">Event Bus</a></h3>
<p>The event bus is a messaging service between the full node and the indexer service. It serves events emitted by the block executor of the full node to the indexer service where events are routed to the relevant indexer component based on type.</p>
<h3 id="block-indexer"><a class="header" href="#block-indexer">Block Indexer</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/state/indexer/block.go#L11">Block Indexer</a> indexes BeginBlock and EndBlock events with an underlying KV store. Block events are indexed by their height, such that matching search criteria returns the respective block height(s).</p>
<h3 id="transaction-indexer"><a class="header" href="#transaction-indexer">Transaction Indexer</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/state/txindex/indexer.go#L14">Transaction Indexer</a> is a key-value store-backed indexer that provides functionalities for indexing and searching transactions. It allows for the addition of a batch of transactions, indexing and storing a single transaction, retrieving a transaction specified by hash, and querying for transactions based on specific conditions. The indexer also supports range queries and can return results based on the intersection of multiple conditions.</p>
<h2 id="message-structurecommunication-format-4"><a class="header" href="#message-structurecommunication-format-4">Message Structure/Communication Format</a></h2>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/state/executor.go#L409"><code>publishEvents</code> method</a> in the block executor is responsible for broadcasting several types of events through the event bus. These events include <code>EventNewBlock</code>, <code>EventNewBlockHeader</code>, <code>EventNewBlockEvents</code>, <code>EventNewEvidence</code>, and <code>EventTx</code>. Each of these events carries specific data related to the block or transaction they represent.</p>
<ol>
<li>
<p><code>EventNewBlock</code>: Triggered when a new block is finalized. It carries the block data along with the results of the <code>FinalizeBlock</code> ABCI method.</p>
</li>
<li>
<p><code>EventNewBlockHeader</code>: Triggered alongside the <code>EventNewBlock</code> event. It carries the block header data.</p>
</li>
<li>
<p><code>EventNewBlockEvents</code>: Triggered when a new block is finalized. It carries the block height, the events associated with the block, and the number of transactions in the block.</p>
</li>
<li>
<p><code>EventNewEvidence</code>: Triggered for each piece of evidence in the block. It carries the evidence and the height of the block.</p>
</li>
<li>
<p><code>EventTx</code>: Triggered for each transaction in the block. It carries the result of the <code>DeliverTx</code> ABCI method for the transaction.</p>
</li>
</ol>
<p>The <code>OnStart</code> method in <code>indexer_service.go</code> subscribes to these events. It listens for new blocks and transactions, and upon receiving these events, it indexes the transactions and blocks accordingly. The block indexer indexes <code>EventNewBlockEvents</code>, while the transaction indexer indexes the events inside <code>EventTx</code>. The events, <code>EventNewBlock</code>, <code>EventNewBlockHeader</code>, and <code>EventNewEvidence</code> are not currently used by the indexer service.</p>
<h2 id="assumptions-and-considerations-4"><a class="header" href="#assumptions-and-considerations-4">Assumptions and Considerations</a></h2>
<p>The indexer service assumes that the messages passed by the block executor are valid block headers and valid transactions with the required fields such that they can be indexed by the respective block indexer and transaction indexer.</p>
<h2 id="implementation-6"><a class="header" href="#implementation-6">Implementation</a></h2>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/state/txindex/indexer_service.go">indexer service</a></p>
<h2 id="references-6"><a class="header" href="#references-6">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/state/indexer/block.go#L11">Block Indexer</a></p>
<p>[2] <a href="https://github.com/rollkit/rollkit/blob/main/state/txindex/indexer.go#L14">Transaction Indexer</a></p>
<p>[3] <a href="https://github.com/rollkit/rollkit/blob/main/state/executor.go#L409">Publish Events</a></p>
<p>[4] <a href="https://github.com/rollkit/rollkit/blob/main/state/txindex/indexer_service.go">Indexer Service</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mempool-1"><a class="header" href="#mempool-1">Mempool</a></h1>
<h2 id="abstract-7"><a class="header" href="#abstract-7">Abstract</a></h2>
<p>The mempool module stores transactions which have not yet been included in a block, and provides an interface to check the validity of incoming transactions. It's defined by an interface <a href="https://github.com/rollkit/rollkit/blob/main/mempool/mempool.go#L32">here</a>, with an implementation <a href="https://github.com/rollkit/rollkit/blob/main/mempool/mempool.go">here</a>.</p>
<h2 id="component-description"><a class="header" href="#component-description">Component Description</a></h2>
<p>Full nodes instantiate a mempool <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go#L96">here</a>. A <code>p2p.GossipValidator</code> is constructed from the node's mempool <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go#L465">here</a>, which is used by Rollkit's P2P code to deal with peers who gossip invalid transactions. The mempool is also passed into the <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go#L158">block manager constructor</a>, which creates a <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L218"><code>BlockExecutor</code></a> from the mempool.</p>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/state/block-executor.md"><code>BlockExecutor</code></a> calls <code>ReapMaxBytesMaxGas</code> in <a href="https://github.com/rollkit/rollkit/blob/main/state/executor.go#L95"><code>CreateBlock</code></a> to get transactions from the pool for the new block. When <code>commit</code> is called, the <code>BlockExecutor</code> calls <a href="https://github.com/rollkit/rollkit/blob/main/state/executor.go#L318"><code>Update(...)</code></a> on the mempool, removing the old transactions from the pool.</p>
<h2 id="communication"><a class="header" href="#communication">Communication</a></h2>
<p>Several RPC methods query the mempool module: <a href="https://github.com/rollkit/rollkit/blob/main/node/full_client.go#L92"><code>BroadcastTxCommit</code></a>, <a href="https://github.com/rollkit/rollkit/blob/main/node/full_client.go#L186"><code>BroadcastTxAsync</code></a>, <a href="https://github.com/rollkit/rollkit/blob/main/node/full_client.go#L202"><code>BroadcastTxSync</code></a> call the mempool's <code>CheckTx(...)</code> method.</p>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function Name</th><th>Input Arguments</th><th>Output Type</th><th>Intended Behavior</th></tr></thead><tbody>
<tr><td>CheckTx</td><td>tx types.Tx, callback func(*abci.Response), txInfo TxInfo</td><td>error</td><td>Executes a new transaction against the application to determine its validity and whether it should be added to the mempool.</td></tr>
<tr><td>RemoveTxByKey</td><td>txKey types.TxKey</td><td>error</td><td>Removes a transaction, identified by its key, from the mempool.</td></tr>
<tr><td>ReapMaxBytesMaxGas</td><td>maxBytes, maxGas int64</td><td>types.Txs</td><td>Reaps transactions from the mempool up to maxBytes bytes total with the condition that the total gasWanted must be less than maxGas. If both maxes are negative, there is no cap on the size of all returned transactions (~ all available transactions).</td></tr>
<tr><td>ReapMaxTxs</td><td>max int</td><td>types.Txs</td><td>Reaps up to max transactions from the mempool. If max is negative, there is no cap on the size of all returned transactions (~ all available transactions).</td></tr>
<tr><td>Lock</td><td>N/A</td><td>N/A</td><td>Locks the mempool. The consensus must be able to hold the lock to safely update.</td></tr>
<tr><td>Unlock</td><td>N/A</td><td>N/A</td><td>Unlocks the mempool.</td></tr>
<tr><td>Update</td><td>blockHeight uint64, blockTxs types.Txs, deliverTxResponses []*abci.ResponseDeliverTx, newPreFn PreCheckFunc, newPostFn PostCheckFunc</td><td>error</td><td>Informs the mempool that the given txs were committed and can be discarded. This should be called <em>after</em> block is committed by consensus. Lock/Unlock must be managed by the caller.</td></tr>
<tr><td>FlushAppConn</td><td>N/A</td><td>error</td><td>Flushes the mempool connection to ensure async callback calls are done, e.g., from CheckTx. Lock/Unlock must be managed by the caller.</td></tr>
<tr><td>Flush</td><td>N/A</td><td>N/A</td><td>Removes all transactions from the mempool and caches.</td></tr>
<tr><td>TxsAvailable</td><td>N/A</td><td>&lt;-chan struct{}</td><td>Returns a channel which fires once for every height when transactions are available in the mempool. The returned channel may be nil if EnableTxsAvailable was not called.</td></tr>
<tr><td>EnableTxsAvailable</td><td>N/A</td><td>N/A</td><td>Initializes the TxsAvailable channel, ensuring it will trigger once every height when transactions are available.</td></tr>
<tr><td>Size</td><td>N/A</td><td>int</td><td>Returns the number of transactions in the mempool.</td></tr>
<tr><td>SizeBytes</td><td>N/A</td><td>int64</td><td>Returns the total size of all txs in the mempool.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="p2p-1"><a class="header" href="#p2p-1">P2P</a></h1>
<p>Every rollup node (both full and light) runs a P2P client using <a href="https://github.com/libp2p/go-libp2p">go-libp2p</a> P2P networking stack for gossiping transactions in the rollup's P2P network. The same P2P client is also used by the header and block sync services for gossiping headers and blocks.</p>
<p>Following parameters are required for creating a new instance of a P2P client:</p>
<ul>
<li>P2PConfig (described below)</li>
<li><a href="https://github.com/libp2p/go-libp2p">go-libp2p</a> private key used to create a libp2p connection and join the p2p network.</li>
<li>chainID: rollup identifier used as namespace within the p2p network for peer discovery. The namespace acts as a sub network in the p2p network, where peer connections are limited to the same namespace.</li>
<li>datastore: an instance of <a href="https://github.com/ipfs/go-datastore">go-datastore</a> used for creating a connection gator and stores blocked and allowed peers.</li>
<li>logger</li>
</ul>
<pre><code class="language-go">// P2PConfig stores configuration related to peer-to-peer networking.
type P2PConfig struct {
	ListenAddress string // Address to listen for incoming connections
	Seeds         string // Comma separated list of seed nodes to connect to
	BlockedPeers  string // Comma separated list of nodes to ignore
	AllowedPeers  string // Comma separated list of nodes to whitelist
}
</code></pre>
<p>A P2P client also instantiates a <a href="https://github.com/libp2p/go-libp2p/tree/master/p2p/net/conngater">connection gator</a> to block and allow peers specified in the <code>P2PConfig</code>.</p>
<p>It also sets up a gossiper using the gossip topic <code>&lt;chainID&gt;+&lt;txTopicSuffix&gt;</code> (<code>txTopicSuffix</code> is defined in <a href="https://github.com/rollkit/rollkit/blob/main/p2p/client.go">p2p/client.go</a>), a Distributed Hash Table (DHT) using the <code>Seeds</code> defined in the <code>P2PConfig</code> and peer discovery using go-libp2p's <code>discovery.RoutingDiscovery</code>.</p>
<p>A P2P client provides an interface <code>SetTxValidator(p2p.GossipValidator)</code> for specifying a gossip validator which can define how to handle the incoming <code>GossipMessage</code> in the P2P network. The <code>GossipMessage</code> represents message gossiped via P2P network (e.g. transaction, Block etc).</p>
<pre><code class="language-go">// GossipValidator is a callback function type.
type GossipValidator func(*GossipMessage) bool
</code></pre>
<p>The full nodes define a transaction validator (shown below) as gossip validator for processing the gossiped transactions to add to the mempool, whereas light nodes simply pass a dummy validator as light nodes do not process gossiped transactions.</p>
<pre><code class="language-go">// newTxValidator creates a pubsub validator that uses the node's mempool to check the
// transaction. If the transaction is valid, then it is added to the mempool
func (n *FullNode) newTxValidator() p2p.GossipValidator {
</code></pre>
<pre><code class="language-go">// Dummy validator that always returns a callback function with boolean `false`
func (ln *LightNode) falseValidator() p2p.GossipValidator {
</code></pre>
<h2 id="references-7"><a class="header" href="#references-7">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/p2p/client.go">client.go</a></p>
<p>[2] <a href="https://github.com/ipfs/go-datastore">go-datastore</a></p>
<p>[3] <a href="https://github.com/libp2p/go-libp2p">go-libp2p</a></p>
<p>[4] <a href="https://github.com/libp2p/go-libp2p/tree/master/p2p/net/conngater">conngater</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rollkit-rpc-equivalency"><a class="header" href="#rollkit-rpc-equivalency">Rollkit RPC Equivalency</a></h1>
<h2 id="abstract-8"><a class="header" href="#abstract-8">Abstract</a></h2>
<p>Rollkit RPC is a remote procedure call (RPC) service that provides a set of endpoints for interacting with a Rollkit node. It supports various protocols such as URI over HTTP, JSONRPC over HTTP, and JSONRPC over WebSockets.</p>
<h2 id="protocolcomponent-description-3"><a class="header" href="#protocolcomponent-description-3">Protocol/Component Description</a></h2>
<p>Rollkit RPC serves a variety of endpoints that allow clients to query the state of the blockchain, broadcast transactions, and subscribe to events. The RPC service follows the specifications outlined in the CometBFT <a href="https://docs.cometbft.com/v0.38/spec/rpc/">specification</a>.</p>
<h2 id="rollkit-rpc-functionality-coverage"><a class="header" href="#rollkit-rpc-functionality-coverage">Rollkit RPC Functionality Coverage</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Routes</th><th>Full Node</th><th>Test Coverage</th></tr></thead><tbody>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#health">Health</a></td><td>✅</td><td>❌</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#status">Status</a></td><td>✅</td><td>🚧</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#netinfo">NetInfo</a></td><td>✅</td><td>❌</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#blockchain">Blockchain</a></td><td>✅</td><td>🚧</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#block">Block</a></td><td>✅</td><td>🚧</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#blockbyhash">BlockByHash</a></td><td>✅</td><td>🚧</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#blockresults">BlockResults</a></td><td>✅</td><td>🚧</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#commit">Commit</a></td><td>✅</td><td>🚧</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#validators">Validators</a></td><td>✅</td><td>🚧</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#genesis">Genesis</a></td><td>✅</td><td>🚧</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#genesischunked">GenesisChunked</a></td><td>✅</td><td>🚧</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#consensusparams">ConsensusParams</a></td><td>✅</td><td>🚧</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#unconfirmedtxs">UnconfirmedTxs</a></td><td>✅</td><td>🚧</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#numunconfirmedtxs">NumUnconfirmedTxs</a></td><td>✅</td><td>🚧</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#tx">Tx</a></td><td>✅</td><td>🚧</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#broadcasttxsync">BroadCastTxSync</a></td><td>✅</td><td>🚧</td></tr>
<tr><td><a href="https://docs.cometbft.com/v0.38/spec/rpc/#broadcasttxasync">BroadCastTxAsync</a></td><td>✅</td><td>🚧</td></tr>
</tbody></table>
</div>
<h2 id="message-structurecommunication-format-5"><a class="header" href="#message-structurecommunication-format-5">Message Structure/Communication Format</a></h2>
<p>The communication format depends on the protocol used. For HTTP-based protocols, the request and response are typically structured as JSON objects. For web socket-based protocols, the messages are sent as JSONRPC requests and responses.</p>
<h2 id="assumptions-and-considerations-5"><a class="header" href="#assumptions-and-considerations-5">Assumptions and Considerations</a></h2>
<p>The RPC service assumes that the Rollkit node it interacts with is running and correctly configured. It also assumes that the client is authorized to perform the requested operations.</p>
<h2 id="implementation-7"><a class="header" href="#implementation-7">Implementation</a></h2>
<p>The implementation of the Rollkit RPC service can be found in the <a href="https://github.com/rollkit/rollkit/blob/main/rpc/json/service.go"><code>rpc/json/service.go</code></a> file in the Rollkit repository.</p>
<h2 id="references-8"><a class="header" href="#references-8">References</a></h2>
<p>[1] <a href="https://docs.cometbft.com/v0.38/spec/rpc/">CometBFT RPC Specification</a>
[2] <a href="https://github.com/rollkit/rollkit/blob/main/rpc/json/service.go">RPC Service Implementation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block-executor-1"><a class="header" href="#block-executor-1">Block Executor</a></h1>
<h2 id="abstract-9"><a class="header" href="#abstract-9">Abstract</a></h2>
<p>The <code>BlockExecutor</code> is a component responsible for creating, applying, and maintaining blocks and state in the system. It interacts with the mempool and the application via the <a href="https://github.com/cometbft/cometbft/blob/main/spec/abci/abci%2B%2B_basic_concepts.md">ABCI interface</a>.</p>
<h2 id="detailed-description-1"><a class="header" href="#detailed-description-1">Detailed Description</a></h2>
<p>The <code>BlockExecutor</code> is initialized with a proposer address, <code>namespace ID</code>, <code>chain ID</code>, <code>mempool</code>, <code>proxyApp</code>, <code>eventBus</code>, and <code>logger</code>. It uses these to manage the creation and application of blocks. It also validates blocks and commits them, updating the state as necessary.</p>
<ul>
<li>
<p><code>NewBlockExecutor</code>: This method creates a new instance of <code>BlockExecutor</code>. It takes a proposer address, <code>namespace ID</code>, <code>chain ID</code>, <code>mempool</code>, <code>proxyApp</code>, <code>eventBus</code>, and <code>logger</code> as parameters. See <a href="https://github.com/rollkit/rollkit/blob/main/block/block-manager.md">block manager</a> for details.</p>
</li>
<li>
<p><code>InitChain</code>: This method initializes the chain by calling ABCI <code>InitChainSync</code> using the consensus connection to the app. It takes a <code>GenesisDoc</code> as a parameter. It sends a ABCI <code>RequestInitChain</code> message with the genesis parameters including:</p>
<ul>
<li>Genesis Time</li>
<li>Chain ID</li>
<li>Consensus Parameters including:
<ul>
<li>Block Max Bytes</li>
<li>Block Max Gas</li>
<li>Evidence Parameters</li>
<li>Validator Parameters</li>
<li>Version Parameters</li>
</ul>
</li>
<li>Initial Validator Set using genesis validators</li>
<li>Initial Height</li>
</ul>
</li>
<li>
<p><code>CreateBlock</code>: This method reaps transactions from the mempool and builds a block. It takes the state, the height of the block, last header hash, and the signature as parameters.</p>
</li>
<li>
<p><code>ApplyBlock</code>: This method applies the block to the state. Given the current state and block to be applied, it:</p>
<ul>
<li>
<p>Validates the block, as described in <code>Validate</code>.</p>
</li>
<li>
<p>Executes the block using app, as described in <code>execute</code>.</p>
</li>
<li>
<p>Captures the validator updates done in the execute block.</p>
</li>
<li>
<p>Updates the state using the block, block execution responses, and validator updates as described in <code>updateState</code>.</p>
</li>
<li>
<p>Returns the updated state, validator updates and errors, if any, after applying the block.</p>
</li>
<li>
<p>It can return the following named errors:</p>
<ul>
<li><code>ErrEmptyValSetGenerate</code>: returned when applying the validator changes would result in empty set.</li>
<li><code>ErrAddingValidatorToBased</code>: returned when adding validators to empty validator set.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Validate</code>: This method validates the block. It takes the state and the block as parameters. In addition to the basic <a href="https://github.com/rollkit/rollkit/blob/main/types/block_spec.md">block validation</a> rules, it applies the following validations:</p>
<ul>
<li>New block version must match block version of the state.</li>
<li>If state is at genesis, new block height must match initial height of the state.</li>
<li>New block height must be last block height + 1 of the state.</li>
<li>New block header <code>AppHash</code> must match state <code>AppHash</code>.</li>
<li>New block header <code>LastResultsHash</code> must match state <code>LastResultsHash</code>.</li>
<li>New block header <code>AggregatorsHash</code> must match state <code>Validators.Hash()</code>.</li>
</ul>
</li>
<li>
<p><code>Commit</code>: This method commits the block and updates the mempool. Given the updated state, the block, and the ABCI <code>ResponseFinalizeBlock</code> as parameters, it:</p>
<ul>
<li>Invokes app commit, basically finalizing the last execution, by  calling ABCI <code>Commit</code>.</li>
<li>Updates the mempool to inform that the transactions included in the block can be safely discarded.</li>
<li>Publishes the events produced during the block execution for indexing.</li>
</ul>
</li>
<li>
<p><code>updateState</code>: This method updates the state. Given the current state, the block, the ABCI <code>ResponseFinalizeBlock</code> and the validator updates, it validates the updated validator set, updates the state by applying the block and returns the updated state and errors, if any. The state consists of:</p>
<ul>
<li>Version</li>
<li>Chain ID</li>
<li>Initial Height</li>
<li>Last Block including:
<ul>
<li>Block Height</li>
<li>Block Time</li>
<li>Block ID</li>
</ul>
</li>
<li>Next Validator Set</li>
<li>Current Validator Set</li>
<li>Last Validators</li>
<li>Whether Last Height Validators changed</li>
<li>Consensus Parameters</li>
<li>Whether Last Height Consensus Parameters changed</li>
<li>App Hash</li>
</ul>
</li>
<li>
<p><code>execute</code>: This method executes the block. It takes the context, the state, and the block as parameters. It calls the ABCI method <code>FinalizeBlock</code> with the ABCI <code>RequestFinalizeBlock</code> containing the block hash, ABCI header, commit, transactions and returns the ABCI <code>ResponseFinalizeBlock</code> and errors, if any.</p>
</li>
<li>
<p><code>publishEvents</code>: This method publishes events related to the block. It takes the ABCI <code>ResponseFinalizeBlock</code>, the block, and the state as parameters.</p>
</li>
</ul>
<h2 id="message-structurecommunication-format-6"><a class="header" href="#message-structurecommunication-format-6">Message Structure/Communication Format</a></h2>
<p>The <code>BlockExecutor</code> communicates with the application via the <a href="https://github.com/cometbft/cometbft/blob/main/spec/abci/abci%2B%2B_basic_concepts.md">ABCI interface</a>. It calls the ABCI methods <code>InitChainSync</code>, <code>FinalizeBlock</code>, <code>Commit</code> for initializing a new chain and creating blocks, respectively.</p>
<h2 id="assumptions-and-considerations-6"><a class="header" href="#assumptions-and-considerations-6">Assumptions and Considerations</a></h2>
<p>The <code>BlockExecutor</code> assumes that there is consensus connection available to the app, which can be used to send and receive ABCI messages. In addition there are some important pre-condition and post-condition invariants, as follows:</p>
<ul>
<li>
<p><code>InitChain</code>:</p>
<ul>
<li>pre-condition:
<ul>
<li>state is at genesis.</li>
</ul>
</li>
<li>post-condition:
<ul>
<li>new chain is initialized.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>CreateBlock</code>:</p>
<ul>
<li>pre-condition:
<ul>
<li>chain is initialized</li>
</ul>
</li>
<li>post-condition:
<ul>
<li>new block is created</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>ApplyBlock</code>:</p>
<ul>
<li>pre-condition:
<ul>
<li>block is valid, using basic <a href="https://github.com/rollkit/rollkit/blob/main/types/block_spec.md">block validation</a> rules as well as validations performed in <code>Validate</code>, as described above.</li>
</ul>
</li>
<li>post-condition:
<ul>
<li>block is added to the chain, state is updated and block execution responses are captured.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Commit</code>:</p>
<ul>
<li>pre-condition:
<ul>
<li>block has been applied</li>
</ul>
</li>
<li>post-condition:
<ul>
<li>block is committed</li>
<li>mempool is cleared of block transactions</li>
<li>block events are published</li>
<li>state App Hash is updated with the result from <code>ResponseCommit</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="implementation-8"><a class="header" href="#implementation-8">Implementation</a></h2>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/state/executor.go">block executor</a></p>
<h2 id="references-9"><a class="header" href="#references-9">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/state/executor.go">Block Executor</a></p>
<p>[2] <a href="https://github.com/rollkit/rollkit/blob/main/block/block-manager.md">Block Manager</a></p>
<p>[3] <a href="https://github.com/rollkit/rollkit/blob/main/types/block_spec.md">Block Validation</a></p>
<p>[4] <a href="https://github.com/cometbft/cometbft/blob/main/spec/abci/abci%2B%2B_basic_concepts.md">ABCI documentation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="store-1"><a class="header" href="#store-1">Store</a></h1>
<h2 id="abstract-10"><a class="header" href="#abstract-10">Abstract</a></h2>
<p>The Store interface defines methods for storing and retrieving blocks, commits, and the state of the blockchain.</p>
<h2 id="protocolcomponent-description-4"><a class="header" href="#protocolcomponent-description-4">Protocol/Component Description</a></h2>
<p>The Store interface defines the following methods:</p>
<ul>
<li><code>Height</code>: Returns the height of the highest block in the store.</li>
<li><code>SetHeight</code>: Sets given height in the store if it's higher than the existing height in the store.</li>
<li><code>SaveBlock</code>: Saves a block along with its seen signature.</li>
<li><code>GetBlock</code>: Returns a block at a given height.</li>
<li><code>GetBlockByHash</code>: Returns a block with a given block header hash.</li>
<li><code>SaveBlockResponses</code>: Saves block responses in the Store.</li>
<li><code>GetBlockResponses</code>: Returns block results at a given height.</li>
<li><code>GetSignature</code>: Returns a signature for a block at a given height.</li>
<li><code>GetSignatureByHash</code>: Returns a signature for a block with a given block header hash.</li>
<li><code>UpdateState</code>: Updates the state saved in the Store. Only one State is stored.</li>
<li><code>GetState</code>: Returns the last state saved with UpdateState.</li>
<li><code>SaveValidators</code>: Saves the validator set at a given height.</li>
<li><code>GetValidators</code>: Returns the validator set at a given height.</li>
</ul>
<p>The <code>TxnDatastore</code> interface inside <a href="https://github.com/ipfs/go-datastore">go-datastore</a> is used for constructing different key-value stores for the underlying storage of a full node. The are two different implementations of <code>TxnDatastore</code> in <a href="https://github.com/rollkit/rollkit/blob/main/store/kv.go">kv.go</a>:</p>
<ul>
<li>
<p><code>NewDefaultInMemoryKVStore</code>: Builds a key-value store that uses the <a href="https://github.com/dgraph-io/badger">BadgerDB</a> library and operates in-memory, without accessing the disk. Used only across unit tests and integration tests.</p>
</li>
<li>
<p><code>NewDefaultKVStore</code>: Builds a key-value store that uses the <a href="https://github.com/dgraph-io/badger">BadgerDB</a> library and stores the data on disk at the specified path.</p>
</li>
</ul>
<p>A Rollkit full node is <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go#L96">initialized</a> using <code>NewDefaultKVStore</code> as the base key-value store for underlying storage. To store various types of data in this base key-value store, different prefixes are used: <code>mainPrefix</code>, <code>dalcPrefix</code>, and <code>indexerPrefix</code>. The <code>mainPrefix</code> equal to <code>0</code> is used for the main node data, <code>dalcPrefix</code> equal to <code>1</code> is used for Data Availability Layer Client (DALC) data, and <code>indexerPrefix</code> equal to <code>2</code> is used for indexing related data.</p>
<p>For the main node data, <code>DefaultStore</code> struct, an implementation of the Store interface, is used with the following prefixes for various types of data within it:</p>
<ul>
<li><code>blockPrefix</code> with value &quot;b&quot;: Used to store blocks in the key-value store.</li>
<li><code>indexPrefix</code> with value &quot;i&quot;: Used to index the blocks stored in the key-value store.</li>
<li><code>commitPrefix</code> with value &quot;c&quot;: Used to store commits related to the blocks.</li>
<li><code>statePrefix</code> with value &quot;s&quot;: Used to store the state of the blockchain.</li>
<li><code>responsesPrefix</code> with value &quot;r&quot;: Used to store responses related to the blocks.</li>
<li><code>validatorsPrefix</code> with value &quot;v&quot;: Used to store validator sets at a given height.</li>
</ul>
<p>For example, in a call to <code>GetBlockByHash</code> for some block hash <code>&lt;block_hash&gt;</code>, the key used in the full node's base key-value store will be <code>/0/b/&lt;block_hash&gt;</code> where <code>0</code> is the main store prefix and <code>b</code> is the block prefix. Similarly, in a call to <code>GetValidators</code> for some height <code>&lt;height&gt;</code>, the key used in the full node's base key-value store will be <code>/0/v/&lt;height&gt;</code> where <code>0</code> is the main store prefix and <code>v</code> is the validator set prefix.</p>
<p>Inside the key-value store, the value of these various types of data like <code>Block</code> is stored as a byte array which is encoded and decoded using the corresponding Protobuf <a href="https://github.com/rollkit/rollkit/blob/main/types/serialization.go">marshal and unmarshal methods</a>.</p>
<p>The store is most widely used inside the <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">block manager</a> and <a href="https://github.com/rollkit/rollkit/blob/main/node/full_client.go">full client</a> to perform their functions correctly. Within the block manager, since it has multiple go-routines in it, it is protected by a mutex lock, <code>lastStateMtx</code>, to synchronize read/write access to it and prevent race conditions.</p>
<h2 id="message-structurecommunication-format-7"><a class="header" href="#message-structurecommunication-format-7">Message Structure/Communication Format</a></h2>
<p>The Store does not communicate over the network, so there is no message structure or communication format.</p>
<h2 id="assumptions-and-considerations-7"><a class="header" href="#assumptions-and-considerations-7">Assumptions and Considerations</a></h2>
<p>The Store assumes that the underlying datastore is reliable and provides atomicity for transactions. It also assumes that the data passed to it for storage is valid and correctly formatted.</p>
<h2 id="implementation-9"><a class="header" href="#implementation-9">Implementation</a></h2>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/store/types.go#L11">Store Interface</a> and <a href="https://github.com/rollkit/rollkit/blob/main/store/store.go">Default Store</a> for its implementation.</p>
<h2 id="references-10"><a class="header" href="#references-10">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/store/types.go#L11">Store Interface</a></p>
<p>[2] <a href="https://github.com/rollkit/rollkit/blob/main/store/store.go">Default Store</a></p>
<p>[3] <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go#L96">Full Node Store Initialization</a></p>
<p>[4] <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">Block Manager</a></p>
<p>[5] <a href="https://github.com/rollkit/rollkit/blob/main/node/full_client.go">Full Client</a></p>
<p>[6] <a href="https://github.com/dgraph-io/badger">Badger DB</a></p>
<p>[7] <a href="https://github.com/ipfs/go-datastore">Go Datastore</a></p>
<p>[8] <a href="https://github.com/rollkit/rollkit/blob/main/store/kv.go">Key Value Store</a></p>
<p>[9] <a href="https://github.com/rollkit/rollkit/blob/main/types/serialization.go">Serialization</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequencer-selection-scheme"><a class="header" href="#sequencer-selection-scheme">Sequencer Selection Scheme</a></h1>
<h2 id="abstract-11"><a class="header" href="#abstract-11">Abstract</a></h2>
<p>The Sequencer Selection scheme describes the process of selecting a block proposer i.e. sequencer from the validator set.</p>
<p>In the first version of Rollkit, this is a fixed pubkey, belonging to the centralized sequencer. The validator set may only ever have one &quot;validator&quot;, the centralized sequencer.</p>
<h2 id="protocolcomponent-description-5"><a class="header" href="#protocolcomponent-description-5">Protocol/Component Description</a></h2>
<p>There is exactly one sequencer which is configured at genesis. <code>GenesisDoc</code> usually contains an array of validators as it is imported from <code>CometBFT</code>. If there is more than one validator defined
in the genesis validator set, an error is thrown.</p>
<p>The <code>Header</code> struct defines a field called <code>ProposerAddress</code> which is the pubkey of the original proposer of the block.</p>
<p>The <code>SignedHeader</code> struct commits over the header and the proposer address and stores the result in <code>LastCommitHash</code>.</p>
<p>A new untrusted header is verified by checking its <code>ProposerAddress</code> and matching it against the best-known header. In case of a mismatch, an error is thrown.</p>
<h2 id="message-structurecommunication-format-8"><a class="header" href="#message-structurecommunication-format-8">Message Structure/Communication Format</a></h2>
<p>The primary structures encompassing validator information include <code>SignedHeader</code>, <code>Header</code>, and <code>State</code>. Some fields are repurposed from CometBFT as seen in <code>GenesisDoc</code> <code>Validators</code>.</p>
<h2 id="assumptions-and-considerations-8"><a class="header" href="#assumptions-and-considerations-8">Assumptions and Considerations</a></h2>
<ol>
<li>There must be exactly one validator defined in the genesis file, which determines the sequencer for all the blocks.</li>
</ol>
<h2 id="implementation-10"><a class="header" href="#implementation-10">Implementation</a></h2>
<p>The implementation is split across multiple functions including <code>IsProposer</code>, <code>publishBlock</code>, <code>CreateBlock</code>, and <code>Verify</code> among others, which are defined in various files like <code>state.go</code>, <code>manager.go</code>, <code>block.go</code>, <code>header.go</code> etc., within the repository.</p>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/block/block-manager.md">block manager</a></p>
<h2 id="references-11"><a class="header" href="#references-11">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/block/block-manager.md">Block Manager</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
